# 정처기를 공부하면서..
> 정처기를 공부하면서 1,2 과목을 공부하다 부트캠프를 하게되고 이후 여러 프로젝트를 진행 이후
다시 정처기 공부로 돌아 왔을 때 나의 견식이 넓어지면서 `프로젝트에 적용 할게 엄청 많구나`를 깨달았다.

### 성능개선의 깨달음
> 특히! 성능 개선에 대해서 고려해볼 엔지니어적 개념들이 매우 많았다
보면서 와 진짜 이런걸 적용해서 설계를 해야하는거구나! 를 배웠다 바로 정리해보자 ㅎㅎ

> 웃긴게 프로젝트를 진행하고 포트폴리오를 작성할 때 나는 성능개선 할게없었는데? 그리고 그런 성능은 도대체 어떤걸 말하는거야? 라고 했는데...
정처기 공부로 돌아갔을 때 `와 진짜 잔뜩있다~`

### 파티션 설계

#### 개념
> 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는것을 말함

- 데용량 DB경우 작은 단위로 나눠 분산 시키면 `성능 저하를 방지`할 뿐 아니라 데이터 관리도 쉬워짐
- 테이블이나 인덱스를 파티셔닝 하면 파티션키 또는 인덱스키에 따라 `물리적`으로 별도의 공간에 데이터가 저장됨
- 데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션 별로 수행

#### 생각
> 사실 해당 개념에 대해 좀 헷갈렸고 파티션키? 하면 DynamoDB에서 밖에 사용하지 않아봤다. 그렇다면 DynamoDB와 같은 개념의 파티션인가?

#### GPT 답변
RDB에서도
CreatedAt 같은 기준으로
물리적으로 DB를 나눌 수 있다는 거야?”

👉 네, 맞습니다. 정확히 그겁니다.
그리고 이건 이론이 아니라 실무에서도 진짜 쓰는 기법이에요.

2️⃣ 지금 준혁님이 하는 구조 = 100% 정상 루트

지금 구조 요약해보면:

Entity entity = Entity.builder()
    .userId(userId)
    .title(title)
    .content(content)
    .createdAt(LocalDateTime.now())
    .build();

repository.save(entity);


이 방식은:

기능적으로 ❌ 문제 없음

설계적으로 ❌ 문제 없음

성능적으로 ❌ 문제 없음 (초기엔)

👉 초기 서비스라면 이게 정석입니다.
여기까지 온 거 자체가 이미 잘한 거예요.

3️⃣ 근데 데이터가 쌓이기 시작하면 생기는 현실 문제

예를 들어:

게시글 테이블 10만 건 → 문제 없음

100만 건 → 약간 느려짐

1,000만 건 → 조회/삭제/백업/인덱스 전부 느려짐

1억 건 → 운영 지옥 시작 😇

여기서 생기는 대표적인 병목:

문제	왜 느려지냐
최근 데이터 조회	테이블 전체 스캔 범위 커짐
오래된 데이터 삭제	DELETE 한 방에 락 오래 걸림
인덱스 커짐	B-Tree 깊이 증가
백업/복구	덩치 커져서 시간 폭증
4️⃣ 여기서 등장하는 게 바로 RDB 파티션 설계

이게 정처기에서 말하는 파티션 설계고,
준혁님 말이 정확히 여기랑 맞닿아 있습니다.

🔹 예시 1: CreatedAt 기준 RANGE 파티션
CREATE TABLE post (
  id BIGINT,
  user_id BIGINT,
  title VARCHAR(200),
  content TEXT,
  created_at DATETIME,
  PRIMARY KEY (id, created_at)
)
PARTITION BY RANGE (YEAR(created_at)) (
  PARTITION p2023 VALUES LESS THAN (2024),
  PARTITION p2024 VALUES LESS THAN (2025),
  PARTITION p2025 VALUES LESS THAN (2026)
);


이게 무슨 효과냐면:

상황	파티션 없을 때	파티션 있을 때
최근 글 조회	테이블 전체 탐색	최신 파티션만 탐색
2023년 글 삭제	전체 테이블 스캔	p2023 파티션만 DROP
인덱스 크기	1억 건짜리	연도별로 쪼개짐
백업	전체 백업	파티션 단위 백업 가능

👉 즉:

CreatedAt 기준으로
물리적으로 테이블이 쪼개진다
(논리적으로는 여전히 하나의 테이블처럼 보임)

5️⃣ 이게 DynamoDB PK 사고방식이랑 왜 비슷하냐면

DynamoDB에서:

PK = userId

SK = createdAt

이렇게 잡으면:

같은 userId + 시간 범위로
Query 빠르게 가능
오래된 데이터 TTL로 제거
핫 파티션 방지

이거랑 완전 동일한 문제를
RDB는 파티션 설계로 해결하는 거예요.

6️⃣ 그래서 준혁님 질문에 대한 딱 한 줄 답

✅ 네, 맞습니다.

지금처럼 Entity 만들어서 save 하는 구조는 그대로 두고

RDB 레벨에서
CreatedAt 같은 컬럼 기준으로
파티션 설계를 적용해서
성능을 개선하는 게 정석 루트입니다.

7️⃣ 근데 중요한 현실 조언 하나 (이거 진짜 중요)

❌ 지금 당장 파티션 안 해도 됩니다.

✅ “언젠가 할 수 있게 컬럼 설계만 맞춰두는 게” 베스트입니다.

즉:

created_at NOT NULL

쿼리에서 created_at 조건 항상 같이 쓰는 습관

PK에 created_at 포함 가능성 열어두기

삭제 정책(보관 기간) 미리 생각

이렇게만 해놔도
나중에 파티션 도입할 때 지옥 안 겪습니다.

### 프로젝트의 진입 방법 및 진행방법의 깨달음
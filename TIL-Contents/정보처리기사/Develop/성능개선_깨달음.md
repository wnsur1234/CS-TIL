# 정처기를 공부하면서..
> 정처기를 공부하면서 1,2 과목을 공부하다 부트캠프를 하게되고 이후 여러 프로젝트를 진행 이후
다시 정처기 공부로 돌아 왔을 때 나의 견식이 넓어지면서 `프로젝트에 적용 할게 엄청 많구나`를 깨달았다.

### 성능개선의 깨달음
> 특히! 성능 개선에 대해서 고려해볼 엔지니어적 개념들이 매우 많았다
보면서 와 진짜 이런걸 적용해서 설계를 해야하는거구나! 를 배웠다 바로 정리해보자 ㅎㅎ

> 웃긴게 프로젝트를 진행하고 포트폴리오를 작성할 때 나는 성능개선 할게없었는데? 그리고 그런 성능은 도대체 어떤걸 말하는거야? 라고 했는데...
정처기 공부로 돌아갔을 때 `와 진짜 잔뜩있다~`

### 파티션 설계

#### 개념
> 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는것을 말함

- 데용량 DB경우 작은 단위로 나눠 분산 시키면 `성능 저하를 방지`할 뿐 아니라 데이터 관리도 쉬워짐
- 테이블이나 인덱스를 파티셔닝 하면 파티션키 또는 인덱스키에 따라 `물리적`으로 별도의 공간에 데이터가 저장됨
- 데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션 별로 수행

#### 생각
> 사실 해당 개념에 대해 좀 헷갈렸고 파티션키? 하면 DynamoDB에서 밖에 사용하지 않아봤다. 그렇다면 DynamoDB와 같은 개념의 파티션인가?

#### GPT 답변
RDB에서도
CreatedAt 같은 기준으로
물리적으로 DB를 나눌 수 있다는 거야?”

👉 네, 맞습니다. 정확히 그겁니다.
그리고 이건 이론이 아니라 실무에서도 진짜 쓰는 기법이에요.

2️⃣ 지금 준혁님이 하는 구조 = 100% 정상 루트

지금 구조 요약해보면:

Entity entity = Entity.builder()
    .userId(userId)
    .title(title)
    .content(content)
    .createdAt(LocalDateTime.now())
    .build();

repository.save(entity);


이 방식은:

기능적으로 ❌ 문제 없음

설계적으로 ❌ 문제 없음

성능적으로 ❌ 문제 없음 (초기엔)

👉 초기 서비스라면 이게 정석입니다.
여기까지 온 거 자체가 이미 잘한 거예요.

3️⃣ 근데 데이터가 쌓이기 시작하면 생기는 현실 문제

예를 들어:

게시글 테이블 10만 건 → 문제 없음

100만 건 → 약간 느려짐

1,000만 건 → 조회/삭제/백업/인덱스 전부 느려짐

1억 건 → 운영 지옥 시작 😇

여기서 생기는 대표적인 병목:

문제	왜 느려지냐
최근 데이터 조회	테이블 전체 스캔 범위 커짐
오래된 데이터 삭제	DELETE 한 방에 락 오래 걸림
인덱스 커짐	B-Tree 깊이 증가
백업/복구	덩치 커져서 시간 폭증
4️⃣ 여기서 등장하는 게 바로 RDB 파티션 설계

이게 정처기에서 말하는 파티션 설계고,
준혁님 말이 정확히 여기랑 맞닿아 있습니다.

🔹 예시 1: CreatedAt 기준 RANGE 파티션
CREATE TABLE post (
  id BIGINT,
  user_id BIGINT,
  title VARCHAR(200),
  content TEXT,
  created_at DATETIME,
  PRIMARY KEY (id, created_at)
)
PARTITION BY RANGE (YEAR(created_at)) (
  PARTITION p2023 VALUES LESS THAN (2024),
  PARTITION p2024 VALUES LESS THAN (2025),
  PARTITION p2025 VALUES LESS THAN (2026)
);


이게 무슨 효과냐면:

상황	파티션 없을 때	파티션 있을 때
최근 글 조회	테이블 전체 탐색	최신 파티션만 탐색
2023년 글 삭제	전체 테이블 스캔	p2023 파티션만 DROP
인덱스 크기	1억 건짜리	연도별로 쪼개짐
백업	전체 백업	파티션 단위 백업 가능

👉 즉:

CreatedAt 기준으로
물리적으로 테이블이 쪼개진다
(논리적으로는 여전히 하나의 테이블처럼 보임)

5️⃣ 이게 DynamoDB PK 사고방식이랑 왜 비슷하냐면

DynamoDB에서:

PK = userId

SK = createdAt

이렇게 잡으면:

같은 userId + 시간 범위로
Query 빠르게 가능
오래된 데이터 TTL로 제거
핫 파티션 방지

이거랑 완전 동일한 문제를
RDB는 파티션 설계로 해결하는 거예요.

6️⃣ 그래서 준혁님 질문에 대한 딱 한 줄 답

✅ 네, 맞습니다.

지금처럼 Entity 만들어서 save 하는 구조는 그대로 두고

RDB 레벨에서
CreatedAt 같은 컬럼 기준으로
파티션 설계를 적용해서
성능을 개선하는 게 정석 루트입니다.

7️⃣ 근데 중요한 현실 조언 하나 (이거 진짜 중요)

❌ 지금 당장 파티션 안 해도 됩니다.

✅ “언젠가 할 수 있게 컬럼 설계만 맞춰두는 게” 베스트입니다.

즉:

created_at NOT NULL

쿼리에서 created_at 조건 항상 같이 쓰는 습관

PK에 created_at 포함 가능성 열어두기

삭제 정책(보관 기간) 미리 생각

이렇게만 해놔도
나중에 파티션 도입할 때 지옥 안 겪습니다.

### 분산 데이터 베이스
> 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 여러 분산되어있는 데이터베이스를 말함

-> 얘는 DynamoDB에서 저장되는 방식과 거의 동일 
하나의 DB에서 파티션키나 이런것에 따라 버전처럼 나뉘어 저장된다는 뜻

<u>`따라서 위에 파티션 설계와 분산데이터베이스를 정리하면` </u>

1️⃣ 지금까지 구조 요약 (준혁님이 해온 거)
spring.jpa.hibernate.ddl-auto: create

@Entity
@Table(name = "post")
public class Post {
    @Id
    private Long id;

    private Long userId;
    private String title;
    private String content;
    private LocalDateTime createdAt;
}


이 상태면 Hibernate가 자동으로:

CREATE TABLE post (
  id BIGINT NOT NULL,
  user_id BIGINT,
  title VARCHAR(200),
  content TEXT,
  created_at DATETIME,
  PRIMARY KEY (id)
);


👉 이게 지금까지 준혁님이 써온 **“JPA 자동 DDL 방식”**입니다.

2️⃣ data.sql로 직접 테이블 만들 경우

지금 준혁님 말한 이 방식 👇

CREATE TABLE post (
  id BIGINT,
  user_id BIGINT,
  title VARCHAR(200),
  content TEXT,
  created_at DATETIME,
  PRIMARY KEY (id, created_at)
);


이건:

❗ Hibernate가 아니라
❗ DB에 직접 물리 구조를 정의하는 방식입니다.

그리고 여기에 👇 이걸 붙이면:

PARTITION BY RANGE (YEAR(created_at)) (
  PARTITION p2023 VALUES LESS THAN (2024),
  PARTITION p2024 VALUES LESS THAN (2025),
  PARTITION p2025 VALUES LESS THAN (2026)
);

3️⃣ 결론: 네, 이게 바로 “RDB 파티션 설계”입니다

즉 최종 형태는:

CREATE TABLE post (
  id BIGINT,
  user_id BIGINT,
  title VARCHAR(200),
  content TEXT,
  created_at DATETIME,
  PRIMARY KEY (id, created_at)
)
PARTITION BY RANGE (YEAR(created_at)) (
  PARTITION p2023 VALUES LESS THAN (2024),
  PARTITION p2024 VALUES LESS THAN (2025),
  PARTITION p2025 VALUES LESS THAN (2026)
);


이게 의미하는 건 딱 이거예요:

논리적으로는 post 테이블 1개

물리적으로는

post#p2023

post#p2024

post#p2025
이렇게 DB 내부에서 나뉘어 저장됨

4️⃣ DBeaver에서 실제로 어떻게 보이냐면

MySQL 기준으로 예를 들면:

① 테이블 목록에는 이렇게 보입니다
post


👉 테이블은 여전히 1개처럼 보입니다.

② 그런데 “Partitions” 탭을 보면
Partitions:
- p2023
- p2024
- p2025


이렇게 나옵니다.

③ 내부적으로는 실제 파일이 따로 있습니다

MySQL 데이터 디렉토리 가보면:

post#p2023.ibd
post#p2024.ibd
post#p2025.ibd


👉 진짜로 물리 파일이 연도별로 쪼개져 있습니다.

5️⃣ “그럼 JPA는 이 구조를 모르는데 괜찮아?”

이게 진짜 중요한 포인트인데요 👇

✅ 네, 전혀 문제 없습니다.

JPA는:

그냥 post 테이블 1개만 안다고 생각하고

평소처럼 INSERT, SELECT 날립니다.

postRepository.save(post);


DB 엔진이 내부적으로:

created_at = 2024-02-01
→ p2024 파티션에 자동 저장


이렇게 처리합니다.

6️⃣ 근데 왜 PRIMARY KEY에 created_at을 같이 넣었냐면

이 부분도 준혁님 이해하면 진짜 끝입니다.

PRIMARY KEY (id, created_at)


이유:

MySQL RANGE 파티션 규칙:

❗ 파티션 키(created_at)는
반드시 모든 UNIQUE KEY / PRIMARY KEY에 포함돼야 함

그래서:

원래 PK: (id)

파티션 후 PK: (id, created_at)

이렇게 바꾼 겁니다.

7️⃣ 그래서 전체 흐름 딱 정리하면

1️⃣ 개발 초기
→ JPA ddl-auto=create
→ 단일 테이블 자동 생성

2️⃣ 데이터 쌓이기 시작
→ 성능 이슈 감지

3️⃣ 운영 단계
→ ddl-auto=none으로 바꿈
→ data.sql에 직접 CREATE TABLE 작성
→ 파티션 구문 추가

4️⃣ 앱 코드는 한 줄도 안 고침
→ DB만 진화함

8️⃣ 준혁님 질문에 대한 딱 한 줄 답

✅ 네, 맞습니다.

data.sql에
PARTITION BY RANGE (...)를 추가하면

MySQL 내부에서 실제 물리 테이블이 나뉘고,

DBeaver에서도
파티션 목록이 따로 보입니다.

그리고 JPA 코드는
전혀 수정할 필요 없습니다.

즉, 한줄 정리하면 기존 방식은 초기 설계방식이고 
-> 데이터가 방대 해질 경우 `개선 방식`

워따 재밌네?

### 프로젝트의 진입 방법 및 진행방법의 깨달음
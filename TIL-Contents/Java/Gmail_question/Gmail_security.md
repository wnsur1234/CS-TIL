# 이메일 인증 구현

> 이메일 인증 번호를 받는데 블로그 글 을 찾아보면 다 하나같이 
내 구글 stmp 인증권한을 설정해놓고 개발을 시작하는데

-> 여기서 나는 어라 왜? 사용자가 사용자의 이메일 내로 인증번호를 받아서 인증절차를 
진행하는데 왜 내 정보를 기입해야하는걸까? 하는 의문이 듦


1. 이메일은 SMTP 서버를 통해 전송된다.
    - 앱이 사용자의 메일함으로 인증코드를 보내려면, 누군가가 `STMP 서버에 로그인해서 메일을 발송` 해야한다.
    - 여기서 쓰는 "구글 정보"는 `발신자 계정 자격증명`(누가보내는지)을 뜻한다.

2. SMTP 서버(Gmail, Naver, 회사 메일, Amazon SES 등)는 인증 없이 메일 발송을 허용하지 않는다.
    - 앱이 “발신자”로 로그인 → 사용자가 입력한 주소로 메일을 보낸다.

-> 어떤 정보를 넣나? 
> Gmail 예: spring.mail.host=smtp.gmail.com, username=your@gmail.com, password=<앱 비밀번호 또는 OAuth2 토큰>, port=587, STARTTLS
  “내 구글 정보” = 발신용 계정 자격증명입니다. 사용자의 구글 정보가 아닙니다

결론, 즉 SMTP 서버에 인증메일을 요청을 하면 각 메일서버의 인증 없이는 메일을 발송하지 않는데 
그 인증을 “서비스가 보유한 발신 전용 계정(서비스 메일 계정)으로 SMTP에 인증한다. 따라서 발신자가 개발자가 되어 발신자 로그인및인증을 한거고 거기에 요청이 오면 
메일을 발송하는 방식이다.

### 보안 포인트
> Gmail을 쓴다면 2단계 인증 + 앱 비밀번호(또는 Oauth2) 사용, 코드/레포에 직입력 금지, 환경변수/시크릿 매니저 사용

### DB의 선택?
> 구현을 들어가기 전 블로그 글들을 확인해 보면 인증번호를 redis에 저장하여 확인하도록 하는데
굳이 왜 reids를 사용하는거지 그냥 RDBS를 사용하면 되는거 아닌가? 라는 의문이 들었음

[답변]
1. TTL이 1급 시민
- 인증코드는 3~10분 같은 짧은 수명입니다.
- Redis는 SET key value EX 300처럼 설정 시점에 자연 만료가 됩니다.
- RDB는 만료를 직접 관리해야 합니다(스케줄러/배치/트리거/이벤트로 삭제). 누락되면 테이블이 계속 불어납니다.

2.  낮은 지연시간과 높은 QPS
- 인증코드 발급/검증은 짧은 폭발 트래픽(로그인/회원가입 피크)에 민감합니다.
- Redis는 메모리 기반이라 읽기/쓰기 지연이 매우 낮고 동시성에 강합니다.

3. 레이트 리밋/시도 횟수 제어가 편함
- INCR, EXPIRE 조합으로 이메일·IP별 시도 횟수, 재발송 쿨다운 등을 손쉽게 구현합니다.
- 원자 연산과 Lua 스크립트로 원샷 검증+소비(consume) 같은 동작을 안전하게 처리할 수 있습니다.
- 일시적·일회성 데이터의 성격
- 인증코드는 영구 보관 가치가 거의 없습니다(오히려 보안상 빨리 사라져야 함).
- 휘발성 데이터는 메모리 스토어에 두고, RDB는 영속·업무 데이터에 집중시키는 분리가 깔끔합니다

---

### 다음으로
> 이제 실제 내 프로젝트에 적용을 해보도록 하겠다.
[실습](./mail_security_practice.md)
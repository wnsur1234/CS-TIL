# ğŸ“š ì•Œê³ ë¦¬ì¦˜ ì „ì²´ ë¶„ë¥˜ ì§€ë„
## ìë£Œêµ¬ì¡°
1. [ìë£Œêµ¬ì¡°](#ìë£Œêµ¬ì¡°)
---
## ì•Œê³ ë¦¬ì¦˜
1. [íƒìƒ‰](#íƒìƒ‰)
2. [ì •ë ¬](#ì •ë ¬)
3. [ì™„ì „íƒìƒ‰](#ì™„ì „íƒìƒ‰--ë°±íŠ¸ë˜í‚¹)
4. [ê·¸ë¦¬ë””](#ê·¸ë¦¬ë””-íƒìš•ë²•)
5. [íˆ¬í¬ì¸í„°](#íˆ¬í¬ì¸í„°)
6. [ìŠ¬ë¼ì´ë”©ìœˆë„ìš°](#ìŠ¬ë¼ì´ë”©-ìœˆë„ìš°)
7. [ì´ë¶„íƒìƒ‰](#ì´ë¶„íƒìƒ‰)
8. [DP](#dp-ë™ì -ê³„íšë²•)
9. [ê·¸ë˜í”„ì•Œê³ ë¦¬ì¦˜](#ê·¸ë˜í”„-ì•Œê³ ë¦¬ì¦˜)
10. [íŠ¸ë¦¬ì•Œê³ ë¦¬ì¦˜](#íŠ¸ë¦¬-ì•Œê³ ë¦¬ì¦˜)
11. [ë¬¸ìì—´ì•Œê³ ë¦¬ì¦˜](#ë¬¸ìì—´-ì•Œê³ ë¦¬ì¦˜)
12. [ë¹„íŠ¸ë§ˆìŠ¤í‚¹](#ë¹„íŠ¸ë§ˆìŠ¤í‚¹)
13. [ì‹œë®¬ë ˆì´ì…˜](#ì‹œë®¬ë ˆì´ì…˜)
x
---
## ìë£Œêµ¬ì¡°
- âœ… ì½”í…Œì—ì„œëŠ” â€œìë£Œêµ¬ì¡° ì„ íƒâ€ì´ ê³§ í’€ì´ì˜ ì ˆë°˜ì…ë‹ˆë‹¤.  
- ë°°ì—´/ë¦¬ìŠ¤íŠ¸/í•´ì‹œ/í/í™/ë±ì€ ê±°ì˜ ë§¤ì¼ ì”ë‹ˆë‹¤.

### ë°°ì—´ (Array)
- ì‚¬ê³ ë ¥ í¬ì¸íŠ¸
    - ì¸ë±ìŠ¤ ì ‘ê·¼ O(1)
    - ì‚½ì…/ì‚­ì œ ëŠë¦¼
    - 2ì°¨ì› ë°°ì—´ì€ ì‹œë®¬ë ˆì´ì…˜/ê·¸ë˜í”„(ê²©ì BFS)ì—ì„œ ìì£¼ ë“±ì¥
```
int[] arr = new int[5];

arr[0] = 10;
int x = arr[0];
arr.length;
```
---
### ArrayList
```
List<Integer> list = new ArrayList<>();

list.add(10);
list.add(1, 20);
list.get(0);
list.set(0, 100);
list.remove(0);
list.size();
list.contains(10);
```
---
### Stack âœ…(ì½”í…Œ ê¶Œì¥: Dequeë¡œ ìŠ¤íƒ êµ¬í˜„)
- Stack í´ë˜ìŠ¤ë„ ë˜ì§€ë§Œ, ì½”í…Œì—ì„œëŠ” ë³´í†µ ArrayDequeë¥¼ ìŠ¤íƒìœ¼ë¡œ ì”ë‹ˆë‹¤(ì„±ëŠ¥/ê´€ë¡€).
- ì‚¬ê³ ë ¥ í¬ì¸íŠ¸
    - `ê´„í˜¸/ë¬¸ìì—´ ì²˜ë¦¬, DFS(ì¬ê·€ ëŒ€ì²´), ë˜ëŒë¦¬ê¸°(Undo)`
```
[Stack]
Stack<Integer> stack = new Stack<>();

stack.push(10);
stack.pop();
stack.peek();
stack.isEmpty();
stack.size();
```
```
[Deque]
Deque<Integer> stack = new ArrayDeque<>();

stack.push(10);      // ì‚½ì…
int a = stack.pop(); // ì œê±°
int top = stack.peek();
boolean empty = stack.isEmpty();
int size = stack.size();
```
---
### Queue
- ì‚¬ê³ ë ¥ í¬ì¸íŠ¸
    - BFS, ë ˆë²¨ íƒìƒ‰, â€œìµœì†Œ íšŸìˆ˜/ìµœë‹¨ ê±°ë¦¬(ê°€ì¤‘ì¹˜ ì—†ëŠ” ê²½ìš°)â€
```
Queue<Integer> queue = new LinkedList<>();

queue.offer(10);
queue.poll();
queue.peek();
queue.isEmpty();
queue.size();
```
---
### Deque
- ì–‘ìª½ ì‚½ì…/ì‚­ì œ ê°€ëŠ¥ â†’ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°(ìµœëŒ“ê°’/ìµœì†Ÿê°’)ì—ì„œ ìì£¼ ì‚¬ìš©
```
Deque<Integer> deque = new LinkedList<>();

deque.addFirst(1);
deque.addLast(2);
deque.pollFirst();
deque.pollLast();
deque.peekFirst();
deque.peekLast();
```
---
6. PriorityQueue (Heap)
- ì‚¬ê³ ë ¥ í¬ì¸íŠ¸
    - â€œê°€ì¥ ì‘ì€/í° ê°’â€ ë°˜ë³µ ì¶”ì¶œ
    - ë‹¤ìµìŠ¤íŠ¸ë¼, ìŠ¤ì¼€ì¤„ë§(ìš°ì„ ìˆœìœ„ ì²˜ë¦¬)
```
PriorityQueue<Integer> pq = new PriorityQueue<>();

pq.offer(10);
pq.poll();
pq.peek();
pq.size();
pq.isEmpty();
```
[ìµœëŒ€ í™]
```
PriorityQueue<Integer> pq =
     new PriorityQueue<>(Collections.reverseOrder());
```
---
### HashMap
- ì‚¬ê³ ë ¥ í¬ì¸íŠ¸
    - ë¹ˆë„ìˆ˜(counting), ì¤‘ë³µì²´í¬, ì¸ë±ì‹±(ê°’â†’ìœ„ì¹˜)
```
HashMap<String, Integer> map = new HashMap<>();

map.put("a", 1);
map.get("a");
map.remove("a");
map.containsKey("a");
map.containsValue(1);
map.keySet();
map.values();
map.size();
```
---
### HashSet
- ì‚¬ê³ ë ¥ í¬ì¸íŠ¸
    - â€œì¡´ì¬ ì—¬ë¶€ O(1)â€ + ì¤‘ë³µ ì œê±°
```
HashSet<Integer> set = new HashSet<>();

set.add(1);
set.remove(1);
set.contains(1);
set.size();
```
---
*** [ì—¬ê¸°ë¶€í„°ëŠ” ì•Œê³ ë¦¬ì¦˜] ***

## íƒìƒ‰
- ì‚¬ê³ ë ¥(íŒë‹¨ ê¸°ì¤€)
    - â€œìµœë‹¨ ê±°ë¦¬/ìµœì†Œ íšŸìˆ˜â€ â†’ BFS
    - â€œëª¨ë“  ê²½ë¡œ/ì—°ê²°ìš”ì†Œ/ê¹Šê²Œâ€ â†’ DFS

### DFS (ê¹Šì´ ìš°ì„ )
> ğŸ‘‰ ì¬ê·€ or ìŠ¤íƒ ì‚¬ìš©

```
void dfs(int node) {
    visited[node] = true;
    for(int next : graph.get(node)) {
        if(!visited[next]) dfs(next);
    }
}
```
### BFS (ë„ˆë¹„ ìš°ì„ )
> ğŸ‘‰ ìµœë‹¨ê±°ë¦¬ ë¬¸ì œì— ìì£¼ ì‚¬ìš©

```
Queue<Integer> queue = new LinkedList<>();
queue.offer(start);
```
---
## ì •ë ¬
- ì •ë ¬ + ê·¸ë¦¬ë”” / íˆ¬í¬ì¸í„° / ì´ë¶„íƒìƒ‰ ì¡°í•©ì´ ë§¤ìš° ìì£¼ ë‚˜ì˜µë‹ˆë‹¤.
- ì‚¬ê³ ë ¥ í¬ì¸íŠ¸
    - â€œì •ë ¬ í›„ ì¡°ê±´ ì²´í¬â€ í˜•íƒœê°€ ì½”í…Œ ë‹¨ê³¨
```
Arrays.sort(arr);
Collections.sort(list);
```
---
## ì™„ì „íƒìƒ‰ / ë°±íŠ¸ë˜í‚¹(ì¬ê·€ë¥¼ ë§í•¨)
- ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.
- ğŸ‘‰ Nì´ ì‘ì„ ë•Œ ì‚¬ìš© (ë³´í†µ 8~10 ì´í•˜)
- ğŸ‘‰ ë°±íŠ¸ë˜í‚¹ì€ â€œê°€ì§€ì¹˜ê¸°â€ê°€ í•µì‹¬

`ì™„ì „íƒìƒ‰` = forë¬¸ìœ¼ë¡œ ëª¨ë‘ ìˆœíšŒ

> ì¶”ê°€[ìˆœì—´]

```
void permutation(int depth) {
    if(depth == N) return;
}
```
---
## ê·¸ë¦¬ë”” (íƒìš•ë²•)
> "ì§€ê¸ˆ ë‹¹ì¥ ìµœì„  ì„ íƒ"

[ì‚¬ìš© ì¡°ê±´]
: ì„ íƒì´ ì „ì²´ ìµœì ì„ ë³´ì¥í•  ë•Œ<br>
ì˜ˆì‹œ: ë™ì „ ë¬¸ì œ (í° ë™ì „ë¶€í„° ì‚¬ìš©)

---
## íˆ¬í¬ì¸í„°
- ë‘ ê°œì˜ ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ğŸ‘‰ ì •ë ¬ëœ ë°°ì—´ì—ì„œ ìì£¼ ì‚¬ìš©
- ì‚¬ê³ ë ¥(íŒë‹¨ ê¸°ì¤€)
    - â€œì •ë ¬ëœ ë°°ì—´ì—ì„œ ë‘ ê°’/ë‘ êµ¬ê°„ì„ ì¢í˜€ê°€ë©° ì°¾ëŠ”ë‹¤â€
    - í•©/ì°¨/ì¡°ê±´ ë§Œì¡± êµ¬ê°„ ì°¾ê¸°
```
int left = 0;
int right = arr.length - 1;

while(left < right) {
    int sum = arr[left] + arr[right];
}
```
---
## ìŠ¬ë¼ì´ë”© ìœˆë„ìš°
- êµ¬ê°„ í•© ë¬¸ì œ
- ğŸ‘‰ ë¶€ë¶„í•© ë¬¸ì œ
- ì‚¬ê³ ë ¥(íŒë‹¨ ê¸°ì¤€)
    - â€œì—°ì†ëœ êµ¬ê°„â€ + â€œì˜¤ë¥¸ìª½ í™•ì¥/ì™¼ìª½ ì¶•ì†Œâ€ êµ¬ì¡°ê°€ ë³´ì´ë©´ ìŠ¬ìœˆ
```
for(int right = 0; right < n; right++) {
    sum += arr[right];
}
```
---
## ì´ë¶„íƒìƒ‰
-  ğŸ‘‰ ì •ë ¬ëœ ìƒíƒœì—ì„œ íƒìƒ‰(ì •ë ¬í•„ìˆ˜)
- ì‚¬ê³ ë ¥(íŒë‹¨ ê¸°ì¤€)
    - â€œì •ë‹µ ë²”ìœ„ë¥¼ ë°˜ìœ¼ë¡œ ì¤„ì¼ ìˆ˜ ìˆë‹¤â€
    - â€œë¡œê·¸ ì‹œê°„ í•„ìš”â€
    - (ì¶”ê°€) â€œì •ë‹µì´ ì–´ë–¤ ê°’ì˜ ìµœì†Œ/ìµœëŒ€â€ë©´ ë§¤ê°œë³€ìˆ˜ íƒìƒ‰ ê°€ëŠ¥ì„± í¼
```
while(left <= right) {
    int mid = (left + right) / 2;
}
```
---
## DP (ë™ì  ê³„íšë²•)
- ì´ì „ ê°’ì„ ì €ì¥
- ğŸ‘‰ ì í™”ì‹ ì°¾ëŠ” ëŠ¥ë ¥ ì¤‘ìš”
- ì‚¬ê³ ë ¥(íŒë‹¨ ê¸°ì¤€)
    - ê°™ì€ ê³„ì‚°ì„ ë°˜ë³µí•œë‹¤(ì¤‘ë³µ ë¶€ë¶„ ë¬¸ì œ)
    - ì´ì „ ìƒíƒœë¡œ í˜„ì¬ë¥¼ ë§Œë“ ë‹¤(ìµœì  ë¶€ë¶„ êµ¬ì¡°)
    - â€œìµœëŒ€/ìµœì†Œ/ê²½ìš°ì˜ ìˆ˜â€ê°€ DP ë‹¨ê³¨
```
int[] dp = new int[n+1];
dp[0] = 0; // ì´ˆê¸°ê°’
dp[1] = 1;

for(int i=2;i<=n;i++){
    dp[i] = dp[i-1] + dp[i-2];
}
```
---
## ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜
> ê·¸ë˜í”„ëŠ” â€œí‘œí˜„ + íƒìƒ‰â€ì´ 50%ì…ë‹ˆë‹¤.

- DFS
- BFS
- ë‹¤ìµìŠ¤íŠ¸ë¼
- í”Œë¡œì´ë“œ ì›Œì…œ
- ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ
- ìœ„ìƒì •ë ¬(DAG ë¬¸ì œ)

---
### ë‹¤ìµìŠ¤íŠ¸ë¼
> ğŸ‘‰ ê°€ì¤‘ì¹˜ ìµœë‹¨ê±°ë¦¬(ìŒìˆ˜ ê°€ì¤‘ì¹˜ X)

```
PriorityQueue<Node> pq = new PriorityQueue<>();
pq.offer(new Node(start,0));

while(!pq.isEmpty()){
    Node now = pq.poll();
}
```
---
### í”Œë¡œì´ë“œ ì›Œì…œ
> ğŸ‘‰ ëª¨ë“  ì •ì  ìµœë‹¨ê±°ë¦¬(Nì´ ì‘ì„ ë•Œ)

```
for(int k=0;k<n;k++)
 for(int i=0;i<n;i++)
  for(int j=0;j<n;j++)
    dist[i][j] = Math.min(dist[i][j],
                          dist[i][k]+dist[k][j]);
```
---
### ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ
- ì—°ê²° ì—¬ë¶€/ì‚¬ì´í´ íŒë³„/MST
- Aë¥¼ ëë‚´ì•¼ B ê°€ëŠ¥â€ ê°™ì€ ë¬¸ì œ

```
int find(int x){
    if(parent[x] == x) return x;
    return parent[x] = find(parent[x]);
}
```
---
### ìœ„ìƒì •ë ¬ (DAG ë¬¸ì œ)
> ì„ í›„ ê´€ê³„ / ì‘ì—… ìˆœì„œ ë¬¸ì œ

```
Queue<Integer> q = new LinkedList<>();

for(int i = 1; i <= n; i++){
    if(indegree[i] == 0) q.offer(i);
}
```
---
## íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜
### MST (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)
#### í¬ë£¨ìŠ¤ì¹¼
- ğŸ‘‰ ê°„ì„  ì •ë ¬ + ìœ ë‹ˆì˜¨íŒŒì¸ë“œ
```
Arrays.sort(edges); // cost ê¸°ì¤€

int total = 0;
for(Edge e : edges){
    if(find(e.u) != find(e.v)){
        union(e.u, e.v);
        total += e.cost;
    }
}
```
---
### ë¬¸ìì—´ ì•Œê³ ë¦¬ì¦˜
- KMP
- íŠ¸ë¼ì´
- ì•„ë‚˜ê·¸ë¨
---
## ë¹„íŠ¸ë§ˆìŠ¤í‚¹
```
int bit = 1 << 3;
```
---
## ì‹œë®¬ë ˆì´ì…˜
- ë¬¸ì œì—ì„œ í•˜ë¼ëŠ” ëŒ€ë¡œ êµ¬í˜„
- ì•Œê³ ë¦¬ì¦˜ì´ ì•ˆ ë– ì˜¤ë¥´ê³  â€œê·œì¹™ëŒ€ë¡œ ì›€ì§ì—¬ë¼/ë°”ê¿”ë¼â€ê°€ í•µì‹¬ì´ë©´ ì‹œë®¬ë ˆì´ì…˜
- êµ¬í˜„ ì‹¤ìˆ˜ ë°©ì§€ê°€ í•µì‹¬(ë°©í–¥ ë°°ì—´ dx/dy ì¶”ì²œ)
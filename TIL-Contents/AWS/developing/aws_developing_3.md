### 3일차

### MAS[모듈11]

### Interaction 패턴

- API 기반
    - 동기식 처리
    - 애플리케이션과 서비스는 API 통해 연결되고 통신
        - AWS 서비스는 서비스 aPI를 제공
    - HTTP 및 s 통신 프로토콜

- 이벤트 기반
    - 비동기식 처리
    - 상황이 발생했음을 알리는 메시지
    - AWS 리소스는 상태 변경 시 이벤트를 생성할 수 있음
    - 소비자가 이벤트를 구독
    - 공급자가 이벤트를 생성

### 모놀리스 애플리케이션 디커플링

- 분리에 적합한 작은 서비스부터 소규모로 시작
- 모놀리스에 대한 종속성 최소화
- 복잡한 종속성은 초기에 분리
- 자주 변경되는 기능 분리하기

ex) 스트랭글러(목졸리기) 설계 패턴
- 단계적 접근 방식
- 지곤 기능을 점진적으로 마이크로서비스로 교체

---

### AWS Step Funtions를 통한 오케스트레이션 
> 람다를 처리할때 중간에서 스무스하게 작동하게 하기 위해 조정을 해주는것

- `시각적 워크플로`를 사용하여 분산 애플리케이션의 구성요소를 조정한다.

#### 워크 플로관리:
- 병렬화
- 장애
- 재시도
- 서비스 통합
- 관찰 기능

### 비지니스 로직 오케스트레이션
![alt text](../../a_images/ocastraition_logic.png)

---

### 애플리케이션의 사용자에게 엑세스 권한 부여하기(로그인)[모듈12]

### AWS Cognito
> 애플리케이션의 인증 및 권한 부여를 해결하는 솔루션

[인증]
- 사용자의 신원 확인
    - HTTP 인증
    - 로그인 프롬프트
    - 사용자 지정 방법
[권한부여]
- 원하는 작업을 사용자가 수행할 수 있는지 확인
    - 엑세스 제어
    - 권한 도구
    - 데이터 및 운영보호

> 소셜 로그인 : 코그니토에서 이것 또한 기능 제공을 한다.

---

### 애플리케이션 배포 [모듈13]

### 배포 계획 수립 및 방식

DevOps 문화 
> 보통 CI/CD만 알고 있는데 사실상 권력 분산이 매우 중요하다 -> 데이터를 흐르게 하는데 이것은 git으로 기록을 남기는것이다.
-> 이런 문화를 남겨야함

DevOps 프로세스
: 코드 -> 구축 -> 테스트 -> 프로비저닝 -> 배포 -> 모니터링
  
CI -> 지속적인 통합 (코드-> 구축-> 테스트)

지속적 전달(devlivery) -> (배포전 결제)

지속적인 배포(deployment) -> (모니터링까지 쭉 이어지는것)


### 다시 서버리스로 포커스를 맞추면 
> SAM 이란? : 서버리스 애플리케이션을 배포하는데 사용되는 오픈 소스 프레임 워크

사실 CloudFormaition의 기능임

### SAM 리소스
[gateway]
AWS::Serverless::Api
AWS::Serverless::HttpApi

[lambda]
AWS::Serverless::Function
AWS::Serverless::LayerVersion

[db]
AWS::Serverless::SimpleTable

[step function]
AWS::Serverless::StateMachine

### 애플리케이션 관찰 [모듈14]
> 결국 CloudWatch임

여기서는 X-ray도 나오는데 

### ☁️ CloudWatch vs X-Ray 비교

| 구분 | CloudWatch | X-Ray |
|------|-------------|-------|
| **목적** | 서버/시스템 수준의 모니터링 | 애플리케이션 내부의 요청 추적 (트레이싱) |
| **관점** | “CPU가 얼마나 쓰이고 있지?”, “에러 몇 개야?” | “요청이 왜 느리지?”, “어디서 지연이 생겼지?” |
| **데이터 단위** | 메트릭(Metric), 로그(Log) | 트레이스(Trace), 세그먼트(Segment) |
| **대표 용도** | 리소스 사용량, 경보 설정, 로그 확인 | 요청 흐름 분석, 병목 구간 추적, 성능 시각화 |
| **보는 화면** | CloudWatch 콘솔 (그래프, 로그) | X-Ray 콘솔 (서비스 맵, 트레이스 타임라인) |

> 즉, CloudWatch는 “전체 서버의 건강상태를 보는 도구”,
X-Ray는 “요청 하나하나의 내부 동작을 들여다보는 도구”입니다.

여기서 그럼 질문 x-ray는 cloudwatch와 별개인가?
-> 별개의 서비스지만, 함께 쓰면 최강 조합이에요.

---

### AWS X-Ray를 사용한 트레이싱
> 애플리케이션 관찰 도구 (Tracing)

### X-Ray란?
> X-Ray는 요청(Request) 이 시스템 내부를 통과할 때,
어떤 서비스, 어떤 함수, 어떤 쿼리를 거치며
얼마나 걸리고, 어디서 병목이 생겼는지 시각화하는 서비스입니다.

### X-Ray 주요 구성요소

| 구성요소 | 설명 |
|-----------|------|
| **Segment** | 한 서비스(예: Lambda) 단위의 작업 단편 |
| **Subsegment** | 내부 함수, SQL 쿼리, 외부 API 호출 등 세부 단계 |
| **Trace** | 요청 전체 흐름(모든 세그먼트 묶음) |
| **Service Map** | 전체 요청 흐름을 그래프로 시각화한 지도 |

---

** 용어**

[메트릭] - “숫자로 표현되는 상태값 (시스템 성능 지표)”
- 즉, 시간에 따라 변하는 측정 가능한 값
- CloudWatch에서 다루는 대표 데이터 단위

[트레이스] - “하나의 요청이 시스템 전체를 통과하는 흐름”
- 트레이스는 X-Ray의 핵심 단위로
    - 사용자 요청이 API Gateway → Lambda → DynamoDB 등을 거치는 전체 경로를 추적
-> 비유하자면
> “메트릭은 체온계로 하루 평균을 보는 것,
트레이스는 병원에서 환자 한 명의 이동 동선을 기록하는 것”이에요.

[세그먼트] - “요청 흐름 중 한 서비스 단위의 기록”
- 트레이스가 전체 여정이라면,
세그먼트는 그 안에서 특정 서비스가 처리한 부분의 로그입니다.
- 그먼트는 다시 세분화되어 “Subsegment”가 될 수도 있습니다.

-> 비유하자면 
> “트레이스가 영화 전체라면, 세그먼트는 한 장면(Scene)”
“Subsegment는 장면 안의 세부 컷(Shot)”